#lab5 ex2
练习2: 父进程复制自己的内存空间给子进程（需要编码）
创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。

一般的copy_range是会给新的进程alloc_page（）物理页的，但如果写时复制的话，可以直接用一个新的目录项，直接复制一份原来的页目录&页表，同时，（这点开销应该不能省吧）然后copy下面的

##copy的思考题答案

请在实验报告中简要说明如何设计实现”Copy on Write 机制“，给出概要设计，鼓励给出详细设计。

对于copy_range，我将函数share参数的语义定义为是否用写时复制的方式实现内存的“复制”。为此，该函数需要在申请页面之前进行判断，若是开启写时复制，则直接使用已存在的页面；在把原来的内容复制到新页面的时候也需要进行判断，若是开启写时复制，就不需要复制了。然后，同样用page_insert完成页表映射和引用计数增加1的操作，但对于写时复制，还需要设置可写位（W位）为0。此外，对于写时复制，还需要将原来页面页表项的可写位（W位）清零并刷新TLB，因为这个页面已经变成共享的页面了。对于dup_mmap，需要将传入给copy_range的share参数变为1（代表开启写时复制）。

此时，对于共享页面的写操作会导致页错误异常，为此需要进一步修改页错误异常处理程序do_pgfault来最终实现写时复制。

do_pgfault已有的代码已经对页面访问权限的情况做了很详细的检查，若能执行到并且通过(*ptep & PTE_P)的判断，说明该进程有权限对该页面进行操作，而该页面又确实真正存在于物理内存中，但此时还是发生了页错误异常，表明页表中存储的权限和该进程实际拥有的权限不一致。这个不一致性告诉内核，这是一个需要写时复制的页面，它可能正在和其它进程共享（如果页面引用计数大于1）。此时，内核才需要真正分配一个新的页面，复制数据，然后修改这个进程的页表项，重新映射对应的虚拟地址，并维护页面的引用计数。这次映射的时候，可写位（W位）就可以设置为1了。

考虑出错页面的引用计数恰好等于1的特殊情况。这个情况说明该页面曾经被共享过，但其他进程又对这个页面进行了写操作，分裂出去了。进一步，这说明该页面已经没有和其他进程共享，只需要修改页表项将此虚拟地址对应的可写位（W位）置1并刷新TLB即可。

至此，写时复制的实现就比较完整了。

另外，我的实现没有考虑挂起的情况。